# 个人开发计划

## 202511

1. 生产数据表格开发
2. TCP和UDP控件开发
3. 串口控件开发

## 控件开发知识

| 特性                                                 | 作用                                                      | 示例                                                         |
| ---------------------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------ |
| `[DefaultEvent("事件名")]`                           | 标记控件的 **默认事件**，使用者拖拽控件后双击即可快速绑定 | 控件最核心的事件（如按钮的 `Click`、表格的 `DataExported`）  |
| `[Category("自定义分类")]`                           | 在属性窗口中分组显示属性（如 “生产控件配置” 组）          | `[Category("生产控件配置"), Description("是否显示导出按钮")]` |
| `[Description("属性描述")]`                          | 鼠标悬停在属性上时显示提示文本                            | `[Description("实时刷新间隔（毫秒），默认1000ms")]`          |
| `[DefaultValue(true)]`                               | 设置属性默认值（设计器中显示 “默认” 标识，重置时恢复）    | `[DefaultValue(true)] public bool ShowExportButtons { get; set; } = true;` |
| `[Browsable(false)]`                                 | 隐藏属性窗口中不需要显示的属性（如内部数据源）            | `[Browsable(false)] public object DataSource { get; set; }`  |
| `[EditorBrowsable(EditorBrowsableState.Never)]`      | 隐藏智能提示中的属性 / 方法（避免暴露内部接口）           | `[EditorBrowsable(EditorBrowsableState.Never)] public void InternalInit()` |
| `[DisplayName("友好名称")]`                          | 自定义属性在设计器中的显示名称（如 “导出按钮可见”）       | `[DisplayName("导出按钮可见")] public bool ShowExportButtons { get; set; }` |
| `[TypeConverter(typeof(ExpandableObjectConverter))]` | 让复杂对象属性在设计器中可展开配置（如自定义样式类）      | `[TypeConverter(typeof(ExpandableObjectConverter))] public GridStyle GridStyle { get; set; }` |

### 重写CreateParams的意义——防止控件闪烁

```markdown
核心作用：解决 Winform 控件闪烁问题
1. 为什么 Winform 控件会闪烁？
Winform 控件默认的绘制逻辑是 “逐控件、逐区域” 绘制：
刷新时先清空控件背景（绘制白色 / 默认背景）；
再逐个绘制子控件（如按钮、表格、文本）；
这个过程中，“清空背景→绘制子控件” 的间隙会导致视觉上的 “闪烁”（尤其是控件复杂、子控件多或刷新频繁时，如实时数据表格、动画控件）。
2. WS_EX_COMPOSITED 样式的解决原理
WS_EX_COMPOSITED 强制 Windows 采用 “双缓冲 + 整体绘制” 策略：
控件刷新时，先将所有内容（自身 + 所有子控件）绘制到 内存中的临时缓冲区（双缓冲）；
缓冲区绘制完成后，一次性将整个缓冲区的内容 “复制” 到屏幕上；
整个过程没有 “清空背景→逐控件绘制” 的间隙，因此完全消除闪烁。
3. 适用场景
这段代码特别适合以下 Winform 控件：
复杂组合控件（如你之前开发的 “生产数据表格”，包含 DataGridView、按钮面板、筛选框等多个子控件）；
实时刷新控件（如数据表格、仪表盘，需要频繁更新 UI）；
子控件数量多的控件（如表单面板、自定义容器）。
三、与 Winform 自带双缓冲的区别
Winform 控件本身有一个 DoubleBuffered 属性（默认 false），也能开启双缓冲，但与这段代码的作用范围不同：
对比项		DoubleBuffered = true					   重写 CreateParams 添加 WS_EX_COMPOSITED
作用范围	仅当前控件（自身绘制），不包含子控件			 当前控件 + 所有子控件（整体绘制）
适用场景	单个简单控件（如自定义绘制的按钮、图表）		复杂组合控件（含多个子控件）
效果		  减少自身闪烁，但子控件多仍可能闪烁				彻底解决整体闪烁（含子控件）
底层实现	控件自身维护缓冲区							Windows 系统级缓冲区（更稳定）
五、注意事项
兼容性：支持 Windows 2000 及以上系统（Winform 目标框架通常都满足，无需担心兼容性问题）；
性能影响：整体双缓冲会占用少量内存（用于缓冲区），但对于现代电脑可忽略不计，且带来的闪烁优化远大于性能损耗；
不要过度使用：简单控件（如单个按钮）无需添加，避免不必要的内存占用；
与其他扩展样式兼容：cp.ExStyle |= 0x02000000 是位运算叠加，不会覆盖其他扩展样式（如 WS_EX_TRANSPARENT 透明样式），可同时使用。


双缓冲是什么？
双缓冲（Double Buffering）是 计算机图形学中解决 UI 闪烁、提升绘制流畅度 的核心技术，本质是通过 “内存缓冲区暂存 + 一次性屏幕刷新” 替代 “直接逐像素绘制到屏幕”，避免绘制过程中的视觉断层。
对于 Winform/WPF 控件开发（尤其是你之前关注的生产数据表格、实时刷新控件），理解双缓冲能帮你彻底解决 “频繁刷新导致的闪烁” 问题。下面用通俗的语言 + 技术细节 + 实际场景，把双缓冲讲透：
一、先看一个生活类比：黑板写字
假设你要在黑板上更新一整页内容，有两种方式：
方式 1：直接擦除 + 逐行写（无缓冲，对应 “单缓冲”）
先用黑板擦把整个黑板擦干净（清空背景）；
逐行、逐字写上新内容；
问题：擦完到写完的过程中，黑板是 “空白→部分内容→完整内容”，视觉上有明显的 “闪烁 / 断层”（尤其是写得慢、内容多时）。
方式 2：先在草稿纸上写好，再整体贴黑板（双缓冲）
拿一张草稿纸（内存缓冲区），在上面完整写好所有新内容；
把原来的黑板擦干净（瞬间完成）；
把草稿纸上的内容 “一次性复制” 到黑板上；
效果：黑板从 “旧内容→新内容” 几乎无间隙，完全看不到中间的空白或半成品，也就没有闪烁。
双缓冲的核心逻辑就是：先在 “内存草稿纸” 上完成所有绘制，再一次性同步到 “屏幕黑板”，跳过中间的 “半成品” 阶段。
二、技术层面：双缓冲的工作原理
在计算机图形学中，“缓冲” 指的是 一块用于存储图像像素数据的内存区域：
前台缓冲：直接显示在屏幕上的内存区域（对应 “黑板”）；
后台缓冲：隐藏在内存中的临时区域（对应 “草稿纸”）。
双缓冲的 3 个核心步骤：
准备后台缓冲：创建一块与控件 / 屏幕大小相同的内存缓冲区；
后台绘制：将所有要显示的内容（如表格数据、按钮、文字、图形）一次性绘制到后台缓冲中（这个过程用户看不到）；
缓冲区交换 / 复制：将后台缓冲中的完整图像，一次性复制到前台缓冲（屏幕），完成刷新。
对比单缓冲（默认绘制方式）：
单缓冲只有 “前台缓冲”，绘制过程是：
清空前台缓冲（擦黑板）；
逐元素绘制（逐字写）；
每绘制一个元素，前台缓冲就会立即显示，导致 “空白→部分内容→完整内容” 的视觉闪烁（尤其是元素多、刷新频繁时）。
三、Winform 中双缓冲的两种实现方式
Winform 为双缓冲提供了两种常用实现，对应不同场景（之前你问的 CreateParams 就是其中一种）：
1. 简单双缓冲（DoubleBuffered 属性）
作用范围：仅当前控件（自身绘制），不包含子控件；
用法：直接设置控件的 DoubleBuffered 属性为 true（默认 false）；
适用场景：单个简单控件（如自定义绘制的按钮、图表、仪表盘）。
csharp
运行
// 示例：自定义绘制的按钮控件
public class CustomButton : Control
{
    public CustomButton()
    {
        DoubleBuffered = true; // 开启双缓冲，避免自身绘制闪烁
    }

    protected override void OnPaint(PaintEventArgs e)
    {
        base.OnPaint(e);
        // 自定义绘制逻辑（如绘制圆角、渐变）
        e.Graphics.FillRoundedRectangle(Brushes.Blue, ClientRectangle, 8);
        e.Graphics.DrawString("自定义按钮", Font, Brushes.White, ClientRectangle, new StringFormat { Alignment = StringAlignment.Center });
    }
}
2. 整体双缓冲（重写 CreateParams 添加 WS_EX_COMPOSITED）
作用范围：当前控件 + 所有子控件（整体绘制）；
用法：重写 CreateParams，添加 0x02000000（WS_EX_COMPOSITED 系统样式）；
适用场景：复杂组合控件（如你的生产数据表格，包含 DataGridView、按钮面板、筛选框等多个子控件）、实时刷新控件。
csharp
运行
// 示例：生产数据表格控件（组合控件）
public partial class ProductionDataGridControl : UserControl
{
    public ProductionDataGridControl()
    {
        InitializeComponent();
        // 配合自身双缓冲，双重优化
        DoubleBuffered = true;
        // 为子控件（如 DataGridView）开启双缓冲（通过反射，因为 DataGridView 的 DoubleBuffered 是 protected）
        EnableDoubleBuffering(dgvMain);
    }

    // 重写 CreateParams，开启整体双缓冲（控件+所有子控件）
    protected override CreateParams CreateParams
    {
        get
        {
            CreateParams cp = base.CreateParams;
            cp.ExStyle |= 0x02000000; // WS_EX_COMPOSITED：系统级整体双缓冲
            return cp;
        }
    }

    // 辅助方法：为子控件开启双缓冲
    private void EnableDoubleBuffering(Control control)
    {
        Type controlType = control.GetType();
        PropertyInfo pi = controlType.GetProperty("DoubleBuffered", BindingFlags.Instance | BindingFlags.NonPublic);
        pi?.SetValue(control, true, null);
    }
}
四、双缓冲的适用场景与注意事项
1. 必须用双缓冲的场景
实时刷新控件：如生产数据表格（每秒刷新）、仪表盘、实时曲线；
复杂组合控件：子控件数量多（如表单面板、自定义容器）；
自定义绘制控件：如圆角按钮、渐变面板、自定义图表（需要频繁重绘）。
2. 无需用双缓冲的场景
静态控件：如标签（Label）、静态图片（PictureBox），几乎不刷新；
简单控件：如原生按钮（Button）、文本框（TextBox），系统已优化，无需额外设置。
3. 注意事项（避免踩坑）
内存占用：双缓冲需要额外的内存存储后台缓冲区（大小 = 控件宽度 × 高度 × 像素字节数），对于超大控件（如全屏表格），可能占用较多内存，但现代电脑可忽略；
性能影响：后台绘制 + 复制的过程会增加少量 CPU 开销，但相比闪烁带来的用户体验损失，完全值得；
Winform 与 WPF 的区别：WPF 默认全局启用双缓冲，因此很少出现闪烁问题；而 Winform 是基于 GDI+ 绘制，默认单缓冲，所以需要手动开启。
五、总结
双缓冲的核心是 “先在内存中画好，再一次性显示”，本质是用少量内存开销换取 “无闪烁的流畅 UI”。
对于你的 Winform 生产数据表格控件：
因为是 组合控件（多子控件）+ 实时刷新，必须用 CreateParams 方式开启整体双缓冲（WS_EX_COMPOSITED）；
同时为子控件（如 DataGridView）和自身开启 DoubleBuffered，双重保障；
最终实现 “高频刷新无闪烁” 的工业级 UI 体验。
```

### Anchor-锚定边缘

```markdow
在 Winform 中，Anchor（锚定）是 控件的核心布局属性，用于定义 “控件与父容器边缘的绑定关系”—— 当父容器（如 Form、Panel、UserControl）大小改变时，控件会按照锚定规则自动调整位置和大小，确保布局始终符合预期。
对于你之前开发的 “生产数据表格控件”（组合控件，包含 DataGridView、按钮面板等子控件），Anchor 是实现 “自适应布局” 的关键，比如让表格随窗口放大 / 缩小而填充整个区域。
一、核心概念：锚定的本质
Anchor 的核心是 “绑定控件的边缘到父容器的对应边缘”，通过 AnchorStyles 枚举（位运算组合）设置，默认值为 Top | Left（控件左上角绑定父容器左上角）。
1. AnchorStyles 枚举值（可组合）
枚举值	含义	效果
None	不锚定任何边缘	父容器大小改变时，控件位置、大小都不变（容易 “悬浮” 在容器中）
Top	锚定父容器顶部边缘	控件顶部与父容器顶部的距离保持不变
Bottom	锚定父容器底部边缘	控件底部与父容器底部的距离保持不变
Left	锚定父容器左侧边缘	控件左侧与父容器左侧的距离保持不变
Right	锚定父容器右侧边缘	控件右侧与父容器右侧的距离保持不变
2. 组合规则（关键）
锚定 相对边缘（如 Left | Right、Top | Bottom）：控件会在对应方向上 拉伸 / 收缩（宽度 / 高度随父容器变化）；
锚定 非相对边缘（如 Top | Right、Bottom | Left）：控件仅 调整位置（大小不变）；
锚定 所有边缘（Top | Bottom | Left | Right）：控件完全填充父容器（随父容器同步放大 / 缩小）。
二、直观示例：锚定效果对比
以 “生产数据表格控件” 中的 DataGridView 为例，不同 Anchor 设置的效果：
示例 1：默认值 Top | Left（最常用基础设置）
csharp
运行
// 表格左上角绑定父容器左上角
dgvMain.Anchor = AnchorStyles.Top | AnchorStyles.Left;
父容器（如窗口）放大时：表格位置不变（左上角始终对齐父容器左上角），大小不变（容易留下空白区域）；
父容器缩小时：表格可能被父容器裁剪（右侧 / 底部超出容器范围）。
示例 2：Top | Left | Right | Bottom（完全填充容器）
csharp
运行
// 表格四个边缘都绑定父容器对应边缘（核心推荐）
dgvMain.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Bottom;
父容器放大 / 缩小时：表格 同步拉伸 / 收缩，始终填充整个父容器（无空白、不裁剪）；
适用场景：DataGridView、Panel 等需要 “占满容器” 的控件（比如你的生产数据表格的核心区域）。
示例 3：Top | Left | Right（水平拉伸，垂直固定）
csharp
运行
// 表格顶部、左侧、右侧锚定，底部不锚定
dgvMain.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right;
父容器宽度改变时：表格宽度同步拉伸 / 收缩（左侧、右侧距离父容器边缘不变）；
父容器高度改变时：表格高度不变（顶部距离父容器边缘不变，底部随父容器移动）；
适用场景：顶部按钮面板（pnlExport）、水平导航栏等。
示例 4：Bottom | Right（右下角固定）
csharp
运行
// 表格右下角绑定父容器右下角
btnRefresh.Anchor = AnchorStyles.Bottom | AnchorStyles.Right;
父容器放大时：按钮会随父容器右下角同步向右 / 向下移动（位置调整，大小不变）；
适用场景：右下角的 “确认”“刷新” 按钮，始终保持在容器右下角。
三、实际应用：生产数据表格控件的自适应布局
结合你之前的控件代码，通过 Anchor 实现 “按钮面板固定顶部，表格填充剩余区域” 的自适应布局：
csharp
运行
public partial class ProductionDataGridControl : UserControl
{
    public ProductionDataGridControl()
    {
        InitializeComponent();
        InitAnchorLayout(); // 初始化锚定布局
    }

    private void InitAnchorLayout()
    {
        // 1. 导出按钮面板（pnlExport）：固定顶部，水平拉伸
        pnlExport.Dock = DockStyle.Top; // 先通过 Dock 固定顶部（Dock 与 Anchor 可配合使用）
        pnlExport.Height = 40;
        pnlExport.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right; 
        // 效果：父容器宽度改变时，面板水平拉伸；高度固定40px，顶部始终对齐父容器顶部

        // 2. 数据表格（dgvMain）：填充剩余区域（核心）
        dgvMain.Location = new Point(0, pnlExport.Height); // 表格顶部对齐面板底部
        dgvMain.Size = new Size(this.Width, this.Height - pnlExport.Height); // 初始大小=容器大小-面板高度
        dgvMain.Anchor = AnchorStyles.Top | AnchorStyles.Left | AnchorStyles.Right | AnchorStyles.Bottom;
        // 效果：父容器放大/缩小时，表格同步拉伸，始终填充面板下方的所有区域

        // 3. 单个按钮（如手动刷新按钮）：固定在面板右侧
        btnRefresh.Anchor = AnchorStyles.Top | AnchorStyles.Right;
        btnRefresh.Location = new Point(pnlExport.Width - 90, 5); // 初始位置靠右侧
        // 效果：面板水平拉伸时，按钮始终保持在面板右侧（距离右侧边缘不变）
    }

    // 配合 OnResize 方法，确保布局更稳定（可选，增强兼容性）
    protected override void OnResize(EventArgs e)
    {
        base.OnResize(e);
        if (pnlExport != null && dgvMain != null)
        {
            // 确保表格位置始终在面板下方，大小始终填充剩余区域
            dgvMain.Location = new Point(0, pnlExport.Height);
            dgvMain.Size = new Size(this.Width, this.Height - pnlExport.Height);
        }
    }
}
最终效果：
窗口放大时：按钮面板水平拉伸，表格同时放大（宽度 + 高度），填充整个窗口；
窗口缩小时：表格同步缩小，不会被裁剪，按钮面板始终固定在顶部；
完全适配不同屏幕尺寸和窗口大小，符合工业软件的自适应需求。
四、Anchor 与 Dock 的区别（避免混淆）
Winform 中还有一个 Dock（停靠）属性，常与 Anchor 混淆，两者核心区别：
对比项	Anchor（锚定）	Dock（停靠）
核心逻辑	绑定控件边缘到父容器边缘，可保留控件原始大小	控件 “吸附” 到父容器的某一边缘 / 填充整个容器，大小强制适配
灵活性	高（可组合边缘，支持位置 + 大小混合调整）	低（仅支持固定方向停靠，如 Top、Bottom、Fill）
适用场景	需自定义位置和拉伸规则（如表格填充、按钮固定角落）	需快速停靠（如顶部面板、左侧导航栏、底部状态栏）
组合使用	可与 Dock 配合（如先 Dock 顶部，再 Anchor 水平拉伸）	不可与其他 Dock 组合（一个控件只能 Dock 一个方向）
最佳实践：
顶部 / 底部面板、状态栏：用 Dock = Top/Bottom；
表格、核心内容区域：用 Anchor = Top | Left | Right | Bottom（填充剩余区域）；
角落按钮、固定大小的控件：用 Anchor = Bottom | Right 等组合（固定位置）。
五、常见问题与解决方案
问题 1：控件锚定后拉伸时出现闪烁
原因：控件（如 DataGridView）未开启双缓冲，拉伸时频繁重绘导致闪烁；
解决方案：结合之前的双缓冲优化，为控件开启双缓冲：
csharp
运行
dgvMain.DoubleBuffered(true); // 扩展方法开启 DataGridView 双缓冲
this.DoubleBuffered = true; // 父控件开启双缓冲
问题 2：锚定 Top | Bottom 后控件高度不拉伸
原因：控件初始高度设置过小，或父容器高度变化范围不足；
解决方案：确保控件初始高度足够，且父容器高度可自由调整（如窗口 FormBorderStyle 设为 Sizable）。
问题 3：多个控件锚定后布局错乱
原因：控件之间存在重叠，或锚定规则冲突（如两个控件都锚定 Bottom | Right 且位置重叠）；
解决方案：用 Panel 对控件分组（如按钮放在面板中），先给面板设置 Dock/Anchor，再给子控件设置锚定，避免直接在父容器中堆砌控件。
六、总结
Anchor 是 Winform 自适应布局的核心属性，本质是 “绑定控件边缘到父容器边缘”，通过组合 AnchorStyles 枚举值，可实现：
控件拉伸 / 收缩（如表格填充容器）；
控件固定位置（如角落按钮）；
复杂组合布局（如面板 + 表格的自适应）。
对于你的生产数据表格控件，最常用的配置是：
按钮面板：Dock = Top + Anchor = Top | Left | Right（固定顶部，水平拉伸）；
数据表格：Anchor = Top | Left | Right | Bottom（填充剩余区域，同步缩放）。
掌握 Anchor 后，可轻松实现工业软件所需的 “窗口大小改变时布局不错乱” 的核心需求，提升控件的实用性和用户体验。
```

### 子控件不是默认继承父控件的属性吗？

```markdown
的理解是 “理想预期”，但 Winform 的实际行为是：子控件默认不会自动继承父控件的属性（如 Font、ForeColor）—— 这是 Winform 原生设计的一个关键特点，和很多 UI 框架（如 WPF、Web 控件）的 “属性继承” 逻辑不同。
核心结论先明确：
Winform 中，子控件的属性（如 Font、BackColor、ForeColor）默认值是 “系统全局默认值”（而非继承父控件的属性值），只有满足特定条件，才会 “被动继承” 父控件属性。
一、为什么默认不继承？（Winform 设计初衷）
Winform 源于早期 Windows 控件模型（Win32），设计理念是 “控件独立性”：
每个子控件都是独立的 Control 对象，拥有自己的属性（Font、ForeColor 等），默认值由系统定义（如 Font 默认为 “Microsoft Sans Serif, 8.25pt”）；
父控件的属性仅作用于自身，不会主动 “传递” 给子控件 —— 这样设计是为了灵活性（允许子控件单独设置样式，如标题用粗体、内容用常规体）。
举个直观例子：
在设计器中拖入一个 UserControl（父控件），再拖入一个 Label（子控件）：
父控件默认 Font 是 “Microsoft Sans Serif, 8.25pt”，子控件默认 Font 也是这个值（不是继承，而是巧合的系统默认值相同）；
手动修改父控件 Font 为 “微软雅黑，12pt”—— 此时子控件 Font 仍为 “Microsoft Sans Serif, 8.25pt”，不会自动跟着变；
只有手动清除子控件的 Font 属性（设为 null 或 “(默认)”），子控件才会 “继承” 父控件的 Font。
二、子控件 “继承” 父控件属性的唯一条件
Winform 控件的属性（如 Font、ForeColor）本质支持 “被动继承”，但必须满足：
条件 1：子控件的该属性未被手动设置（值为 null 或系统默认的 “未指定” 状态）
设计时拖入的子控件：默认会绑定系统字体（Font 属性有具体值，而非 null），因此不会继承父控件属性；
代码创建的子控件：若未显式设置 Font（label1.Font = null 或不赋值），则会自动 “继承” 父控件的 Font。
条件 2：父控件已设置该属性（非默认值）
父控件的属性需有明确值（如手动设置了 Font），子控件才能 “继承” 到有效内容。
验证代码（代码创建子控件，默认继承）：
csharp
运行
public partial class IndicatorControl : UserControl
{
    public IndicatorControl()
    {
        InitializeComponent();

        // 父控件设置 Font（非系统默认值）
        this.Font = new Font("微软雅黑", 12pt);

        // 代码创建子控件，未设置 Font（值为 null）
        Label lblName = new Label { Text = "指示灯01：" };
        Button btnStart = new Button { Text = "启动" };

        Controls.Add(lblName);
        Controls.Add(btnStart);

        // 此时 lblName.Font 和 btnStart.Font 会自动等于父控件的 Font（12pt 微软雅黑）
    }
}
验证代码（设计器拖入子控件，需手动清除属性）：
csharp
运行
public partial class IndicatorControl : UserControl
{
    public IndicatorControl()
    {
        InitializeComponent();

        this.Font = new Font("微软雅黑", 12pt);

        // 设计器拖入的子控件，Font 有默认值（需手动设为 null 才会继承）
        lblName.Font = null; // 清除后，继承父控件 Font
        btnStart.Font = null; // 清除后，继承父控件 Font
    }
}
三、为什么你会误以为 “默认继承”？
很多开发者会有这个误解，核心原因是：
默认值巧合相同：父控件和子控件的默认 Font、ForeColor 都是系统默认值，看起来像 “继承”，实则是各自独立的默认值；
部分属性例外：少数属性（如 Enabled、Visible）会默认 “继承” 父控件状态（父控件设为 Enabled = false，子控件也会禁用），但这是特殊逻辑，并非所有属性都如此；
混淆了 “布局属性” 和 “样式属性”：Anchor、Dock 等布局属性是子控件相对于父控件的规则，不是 “继承”，和 Font、ForeColor 等样式属性完全不同。
四、关键区别：“默认值相同” vs “真正继承”
场景	本质	表现
子控件未清除 Font（设计器拖入）	子控件使用自身默认值（系统字体）	父控件修改 Font，子控件不变
子控件清除 Font（设为 null）	子控件被动继承父控件 Font	父控件修改 Font，子控件自动同步
代码创建子控件（未设 Font）	子控件被动继承父控件 Font	父控件修改 Font，子控件自动同步
五、总结
子控件 默认不会主动继承 父控件的属性（如 Font、ForeColor），默认值是系统全局默认值；
只有满足 “子控件属性为 null（未手动设置）”，子控件才会 被动继承 父控件的对应属性；
设计时拖入的子控件需手动清除属性（设为 null 或 “(默认)”），代码创建的子控件无需额外设置（默认 null），才能实现 “继承”。
这就是为什么之前需要通过 “重写父控件属性 + 同步子控件” 或 “清除子控件属性” 的方案，来实现你想要的 “子控件继承父控件属性并响应修改” 的效果 —— 本质是弥补 Winform 原生 “不主动继承” 的设计特点。
```



## 生产数据表格开发

开发目标

| 功能     | 实现方式                                                    |
| -------- | ----------------------------------------------------------- |
| 数据绑定 | 支持 `List<T>`、`DataTable` 等数据源，自动生成列            |
| 实时刷新 | 内置定时器，支持自定义间隔，跨线程安全更新                  |
| 数据导出 | 导出 CSV/Excel（需安装 EPPlus 包），支持选中行 / 全部行导出 |
| 筛选排序 | 表头嵌入筛选框，支持模糊筛选；表格自带排序功能              |
| 样式美化 | 工业风配色（深色表头 + 交替行），列宽自适应                 |
| 右键菜单 | 支持复制选中行、手动刷新、快速导出                          |
| 事件通知 | 导出完成、数据刷新完成事件，便于日志记录                    |



## NewSerialPort开发

### API

| 自定义属性 | 用法 | 含义 |
| ---------- | ---- | ---- |
|            |      |      |
|            |      |      |
|            |      |      |

需要实现的功能

- [ ] 固定发送的命令、配置文件保存的位置可以属性配置
- [ ] 接收事件可以事件配置
- [ ] 测试连接
  - [ ] 使用属性配置的命令去使用


## 控件的自定义开发

参考链接：

1. B站付工上位机，看完提升不大【关于自定义控件和自定义事件，这节课如果你还听不懂，找我】 https://www.bilibili.com/video/BV1Lv411L7BC/?share_source=copy_web&vd_source=1faf6f8be863497a8aa161f8493e14d2
2. 

### 关于自定义控件和自定义事件，这节课如果你还听不懂，找我

#### 属性设计

完整写法和简写的区别

```c#
  //完整写法,可以在get/set中加入业务逻辑
	private int ledNo;
  public int LedNo
  {
      get { return ledNo; }
      set { ledNo = value; }
  }

	public int LedNo { get; set; }//简写，无法加逻辑
```

#### 属性是否可以在设计时修改

如果属性或事件可以在设计时修改，则为 `true`；否则为 `false`。 默认值为 `true`。

```c#
[Browsable(true)]
public int MyProperty
{
    get
    {
        // Insert code here.
        return 0;
    }
    set
    {
        // Insert code here.
    }
}
```

#### 常用特性

```c#
private int ledNo;

[Browsable(true)]//属性页面展示
[Category("Test")]//分类
[Description("指示灯号")]//描述
public int LedNo
{
    get { return ledNo; }
    set
    {
        ledNo = value;
        this.uiLabel1.Text = "指示灯" + ledNo.ToString().PadLeft(2, '0') + ":";
    }
}
```

